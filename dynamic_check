import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import requests
import pandas as pd
import threading
from urllib.parse import urlparse
try:
    from bs4 import BeautifulSoup
    _HAS_BS4 = True
except Exception:
    _HAS_BS4 = False

# ---------------------------
# URL Checking Logic (enhanced authenticity checks)
# ---------------------------

def get_domain(url):
    try:
        parsed = urlparse(url)
        host = parsed.netloc.lower()
        # strip leading www.
        if host.startswith("www."):
            host = host[4:]
        return host
    except Exception:
        return ""

def fetch_with_redirects(url, timeout=10):
    """
    Fetch the URL with redirects allowed and return the Response object or None.
    """
    try:
        r = requests.get(url, timeout=timeout, allow_redirects=True)
        return r
    except Exception:
        return None

def extract_canonical_from_html(html, base_url=""):
    """
    Try to extract canonical URL from HTML using bs4 when available.
    Fallback: return empty string.
    """
    if not _HAS_BS4 or not html:
        return ""
    try:
        soup = BeautifulSoup(html, "lxml")
    except Exception:
        try:
            soup = BeautifulSoup(html, "html.parser")
        except Exception:
            return ""
    # look for <link rel="canonical" href="...">
    link = soup.find("link", rel=lambda x: x and "canonical" in x.lower())
    if link and link.get("href"):
        return link["href"].strip()
    # look for og:url meta
    meta = soup.find("meta", property="og:url")
    if meta and meta.get("content"):
        return meta["content"].strip()
    # fallback to empty
    return ""

def check_url(url):
    """
    Returns tuple:
    (status_label, redirect_to, final_url, http_code, canonical_url, authentic_flag)
    """
    redirect_to = ""
    final_url = ""
    canonical_url = ""
    code = ""
    try:
        # First try a HEAD request to quickly detect redirects if server allows it
        try:
            head = requests.head(url, timeout=8, allow_redirects=False)
            code = head.status_code
            if code in (301, 302) and head.headers.get("Location"):
                redirect_to = head.headers.get("Location")
                # resolve final via a full GET with redirects allowed
                r = fetch_with_redirects(redirect_to)
                if r:
                    final_url = r.url
                    code = r.status_code
                    # try to get canonical from r.text
                    canonical_url = extract_canonical_from_html(r.text, r.url)
                else:
                    # fallback: try resolving original URL with redirects allowed
                    r2 = fetch_with_redirects(url)
                    if r2:
                        final_url = r2.url
                        code = r2.status_code
                        canonical_url = extract_canonical_from_html(r2.text, r2.url)
                return ("Redirect", redirect_to or "", final_url or "", code, canonical_url or "", determine_authenticity(url, final_url, canonical_url))
        except Exception:
            # some servers disallow HEAD; fall back to GET
            pass

        # Regular GET (follows redirects)
        r = fetch_with_redirects(url)
        if r:
            code = r.status_code
            final_url = r.url
            # extract canonical
            canonical_url = extract_canonical_from_html(r.text, r.url)
            if code == 200:
                return ("Working", "", final_url, code, canonical_url or "", determine_authenticity(url, final_url, canonical_url))
            elif code in (301, 302):
                # although allow_redirects=True should have followed, handle anyway
                redirect_to = r.headers.get("Location", "")
                return ("Redirect", redirect_to or "", final_url or "", code, canonical_url or "", determine_authenticity(url, final_url, canonical_url))
            else:
                return (f"Error {code}", "", final_url or "", code, canonical_url or "", determine_authenticity(url, final_url, canonical_url))
        else:
            return ("Failed", "", "", "", "", "Unknown")
    except Exception:
        return ("Failed", "", "", "", "", "Unknown")

def determine_authenticity(original_url, final_url, canonical_url):
    """
    Decide whether final/canonical point to the same base domain as the original.
    Returns "Yes", "No", or "Unknown".
    Logic:
      - If final_url domain endswith original base domain -> Yes
      - Else if canonical_url domain endswith original base domain -> Yes
      - Else if final_url is empty and canonical empty -> Unknown
      - Else No
    This is dynamic: it derives the original base domain from original_url, so it works for different universities.
    """
    try:
        base = get_domain(original_url)
        if not base:
            return "Unknown"
        final_domain = get_domain(final_url) if final_url else ""
        canonical_domain = get_domain(canonical_url) if canonical_url else ""
        # compare using endswith to allow subdomains (e.g., courses.cardiffmet.ac.uk -> cardiffmet.ac.uk)
        if final_domain and final_domain.endswith(base):
            return "Yes"
        if canonical_domain and canonical_domain.endswith(base):
            return "Yes"
        # also consider if canonical_url contains base even if domain parsing failed
        if canonical_url and base in canonical_url:
            return "Yes"
        if final_url and base in final_url:
            return "Yes"
        if not final_url and not canonical_url:
            return "Unknown"
        return "No"
    except Exception:
        return "Unknown"

# ---------------------------
# Load / Export
# ---------------------------

def load_file():
    path = filedialog.askopenfilename(
        filetypes=[("Excel/CSV Files", "*.xlsx *.csv"), ("All files", "*.*")]
    )
    if not path:
        return
    try:
        if path.lower().endswith(".csv"):
            df = pd.read_csv(path)
        else:
            df = pd.read_excel(path)
        if "URL" not in df.columns:
            messagebox.showerror("Error", "Your file must contain a column named 'URL'")
            return
        input_box.delete("1.0", tk.END)
        for url in df["URL"].dropna().astype(str).tolist():
            input_box.insert(tk.END, url.strip() + "\n")
        messagebox.showinfo("Loaded", f"Loaded {len(df)} URLs (rows in file).")
    except Exception as e:
        messagebox.showerror("Error", str(e))

def export_results():
    if not results_data:
        messagebox.showerror("Error", "No results to export.")
        return
    path = filedialog.asksaveasfilename(defaultextension=".xlsx", filetypes=[("Excel", "*.xlsx"), ("CSV", "*.csv")])
    if not path:
        return
    df = pd.DataFrame(results_data)
    try:
        if path.lower().endswith(".csv"):
            df.to_csv(path, index=False)
        else:
            df.to_excel(path, index=False)
        messagebox.showinfo("Saved", f"Saved results to {path}")
    except Exception as e:
        messagebox.showerror("Error", str(e))

# ---------------------------
# Worker
# ---------------------------

results_data = []

def start_check():
    threading.Thread(target=check_links, daemon=True).start()

def check_links():
    global results_data
    results_data = []
    # clear tree
    for it in tree.get_children():
        tree.delete(it)

    raw = input_box.get("1.0", tk.END).strip()
    if not raw:
        messagebox.showerror("Error", "Please paste URLs (one per line).")
        return
    urls = [u.strip() for u in raw.splitlines() if u.strip()]
    total = len(urls)
    progress["maximum"] = total
    progress["value"] = 0
    count_label.config(text=f"Checked: 0/{total}")
    root.update_idletasks()

    working = redirected = broken = 0

    for i, url in enumerate(urls, start=1):
        status, redirect_to, final_url, code, canonical_url, authentic = check_url(url)
        results_data.append({
            "Original URL": url,
            "Status": status,
            "Redirect To": redirect_to,
            "Final URL": final_url,
            "Canonical URL": canonical_url,
            "Authentic Source": authentic,
            "HTTP Code": code
        })

        # determine row color tag
        if status == "Working" and authentic == "Yes":
            tag = "green"
            working += 1
        elif status == "Working" and authentic != "Yes":
            # working but authenticity unclear/false -> blue
            tag = "blue"
            working += 1
        elif status == "Redirect":
            tag = "blue"
            redirected += 1
        else:
            tag = "red"
            broken += 1

        tree.insert("", "end", values=(url, status, redirect_to, final_url, canonical_url, authentic, code), tags=(tag,))

        # update progress
        progress["value"] = i
        count_label.config(text=f"Checked: {i}/{total}")
        root.update_idletasks()

    # final summary label update
    summary_text = f"Total: {total} | Working: {working} | Redirects: {redirected} | Broken/Failed: {broken}"
    summary_label.config(text=summary_text)

    # show completion popup with final counts
    messagebox.showinfo("Completed", f"URL check completed.\n\n{summary_text}")

# ---------------------------
# Tree selection + Copy helpers
# ---------------------------

def on_tree_double_click(event):
    # copy original url to clipboard on double-click
    copy_selected_field("Original URL")

def copy_selected_field(field_name):
    sel = tree.selection()
    if not sel:
        status_bar.set("No row selected to copy.")
        return
    item = sel[0]
    vals = tree.item(item, "values")
    # columns: 0=URL,1=Status,2=Redirect To,3=Final URL,4=Canonical URL,5=Authentic Source,6=Code
    mapping = {
        "Original URL": 0,
        "Status": 1,
        "Redirect To": 2,
        "Final URL": 3,
        "Canonical URL": 4,
        "Authentic Source": 5,
        "HTTP Code": 6,
        "Row": None
    }
    idx = mapping.get(field_name)
    if idx is None:
        # copy the entire row as tab separated
        text = "\t".join(str(v) for v in vals)
    else:
        text = str(vals[idx]) if idx < len(vals) else ""
    if not text:
        status_bar.set("Selected field is empty.")
        return
    root.clipboard_clear()
    root.clipboard_append(text)
    status_bar.set(f"Copied {field_name} to clipboard.")

def on_copy_shortcut(event):
    # Ctrl+C copies the Original URL of the currently selected row
    copy_selected_field("Original URL")

def show_context_menu(event):
    # select row under pointer
    iid = tree.identify_row(event.y)
    if iid:
        tree.selection_set(iid)
    menu.post(event.x_root, event.y_root)

# ---------------------------
# GUI Setup
# ---------------------------

root = tk.Tk()
root.title("URL Checker â€” Column View (Authenticity Verified)")
root.geometry("1200x780")

# Top: input and buttons
top_frame = tk.Frame(root)
top_frame.pack(fill="x", padx=8, pady=6)

tk.Label(top_frame, text="Paste URLs (one per line):", font=("Segoe UI", 11)).pack(anchor="w")
input_box = tk.Text(top_frame, height=6, width=140, font=("Segoe UI", 10))
input_box.pack(pady=4)

btns = tk.Frame(top_frame)
btns.pack(fill="x", pady=4)
tk.Button(btns, text="Load from Excel/CSV", command=load_file).pack(side="left", padx=4)
tk.Button(btns, text="Check Links", bg="#0b61a4", fg="white", command=start_check).pack(side="left", padx=6)
tk.Button(btns, text="Export Results", bg="#2d7a2d", fg="white", command=export_results).pack(side="left", padx=6)

# Progress
progress = ttk.Progressbar(root, length=1000)
progress.pack(pady=6)
count_label = tk.Label(root, text="Checked: 0/0", font=("Segoe UI", 10))
count_label.pack()

# Treeview (table)
columns = ("Original URL", "Status", "Redirect To", "Final URL", "Canonical URL", "Authentic Source", "HTTP Code")
tree = ttk.Treeview(root, columns=columns, show="headings", height=20)
tree.pack(padx=8, pady=8, fill="both", expand=True)

for col in columns:
    tree.heading(col, text=col)
    # allow flexible column width
    if col == "Original URL":
        tree.column(col, width=340, anchor="w")
    elif col in ("Final URL", "Canonical URL"):
        tree.column(col, width=300, anchor="w")
    elif col == "Redirect To":
        tree.column(col, width=260, anchor="w")
    elif col == "Authentic Source":
        tree.column(col, width=110, anchor="center")
    else:
        tree.column(col, width=100, anchor="center")

# color tags
tree.tag_configure("green", foreground="green")
tree.tag_configure("red", foreground="red")
tree.tag_configure("blue", foreground="blue")

# Bindings: double-click, right-click menu, Ctrl+C
tree.bind("<Double-1>", on_tree_double_click)
root.bind_all("<Control-c>", on_copy_shortcut)

# Context menu for copying different columns
menu = tk.Menu(root, tearoff=0)
menu.add_command(label="Copy Original URL", command=lambda: copy_selected_field("Original URL"))
menu.add_command(label="Copy Final URL", command=lambda: copy_selected_field("Final URL"))
menu.add_command(label="Copy Redirect To", command=lambda: copy_selected_field("Redirect To"))
menu.add_command(label="Copy Canonical URL", command=lambda: copy_selected_field("Canonical URL"))
menu.add_command(label="Copy Authentic Source", command=lambda: copy_selected_field("Authentic Source"))
menu.add_command(label="Copy Status", command=lambda: copy_selected_field("Status"))
menu.add_command(label="Copy HTTP Code", command=lambda: copy_selected_field("HTTP Code"))
menu.add_separator()
menu.add_command(label="Copy Entire Row", command=lambda: copy_selected_field("Row"))
tree.bind("<Button-3>", show_context_menu)  # right click

# Summary
summary_label = tk.Label(root, text="Total: 0 | Working: 0 | Redirects: 0 | Broken: 0", font=("Segoe UI", 11, "bold"))
summary_label.pack(pady=6)

# Status bar (one-line messages)
status_frame = tk.Frame(root)
status_frame.pack(fill="x", side="bottom")
status_bar = tk.StringVar()
status_bar.set("Ready")
status_label = tk.Label(status_frame, textvariable=status_bar, anchor="w")
status_label.pack(fill="x", padx=6, pady=4)

# Allow column resizing by user
def enable_column_resize(event):
    for col in columns:
        tree.column(col, stretch=True)
root.bind("<Configure>", enable_column_resize)

root.mainloop()
